# Gen Docs

Generate structured project documentation for AI context.

```
┌─────────────┐    ┌─────────────┐    ┌──────────────────────────────┐    ┌─────────────┐
│  PHASE 0    │    │  PHASE 1    │    │  PHASE 2                     │    │  PHASE 3    │
│  Resume     │    │  Setup      │    │  Preview Loop                │    │  Generate   │
│             │    │             │    │                              │    │             │
│ read .tmp   │───>│ project     │───>│ 2.1 launch agents → scan    │───>│ write docs/ │
│ resume or   │    │ type?       │    │ 2.2 build preview in .tmp   │    │ from approved│
│ start fresh │    │ skip docs?  │    │ 2.3 show preview to user    │    │ preview     │
│             │    │             │    │ 2.4 ask: deepen/adjust/go   │    │             │
│             │    │             │    │     ↻ loop until "go"       │    │             │
└─────────────┘    └─────────────┘    └──────────────────────────────┘    └─────────────┘
```

## State File

All progress is tracked in `.gen-docs-state.tmp` at the project root.

After `Step 1.3` (header only):
```
phase: 2
type: monorepo
docs: overview,architecture,repo,concepts,db,cicd,rules,guides,features,platform,parts,problems
```

After `Step 2.2` (preview appended):
```
phase: 2
type: monorepo
docs: overview,architecture,repo,concepts,db,cicd,rules,guides,features,platform,parts,problems

--- PREVIEW ---

overview.md:
  - project: My App - description here
  - related repos: repo-a, repo-b
  - doc index: 12 files across docs/

features/auth.md:
  - email/password + Google OAuth
  - JWT with refresh rotation
  - role-based: guest, host, admin

features/booking.md:
  - availability check → hold → payment → confirm
  - cancellation policies: flexible, moderate, strict

...etc
```

---

## Phase 0 - Resume Check

1. Check if `.gen-docs-state.tmp` exists in the project root
2. If it EXISTS:
   - Read it and parse the phase number
   - Use `AskUserQuestion` to ask:
     - question: "Found existing gen-docs session at phase {N}. What do you want to do?"
     - options:
       - "Resume from phase {N}" (Recommended)
       - "Start fresh (delete state)"
   - If resume: jump to the saved phase
   - If fresh: delete `.gen-docs-state.tmp`, proceed to `## Phase 1`
3. If it does NOT exist:
   - Proceed to `## Phase 1`

---

## Phase 1 - Setup

### Step 1.1 - Ask project type

Use `AskUserQuestion`:
- question: "What type of project is this?"
- header: "Project type"
- options:
  - label: "Single Repo"
    description: "One language/concern, personal projects, libraries, single-service apps"
  - label: "Monorepo"
    description: "Multiple parts (api, frontend, infra), multi-team, multiple package.json"

### Step 1.2 - Ask which docs to SKIP

All docs are generated by default. We ask the user what to SKIP (inverted question).
This way the user only checks the few they don't want instead of checking everything.

Use a SINGLE `AskUserQuestion` call with 2 questions (all multiSelect: true).
The tool supports up to 4 questions per call, each with up to 4 options.

Question 1:
- question: "All docs are generated by default. Check any you want to SKIP:"
- header: "Skip docs?"
- multiSelect: true
- options:
  - label: "Skip concepts.md"     description: "Domain glossary (skip if trivial domain)"
  - label: "Skip db.md"           description: "Data model, DB config, migrations, seeds, caching (skip if no DB)"
  - label: "Skip cicd.md"         description: "CI/CD pipelines, deploy workflows, secrets"
  - label: "Skip guides/"         description: "How-to docs, practical knowledge, recipes"

Question 2:
- question: "Any of these to skip too?"
- header: "Skip more?"
- multiSelect: true
- options (if SINGLE REPO):
  - label: "Skip features/"       description: "One doc per product feature"
  - label: "Skip rules.md"        description: "Principles, conventions, anti-patterns"
- options (if MONOREPO):
  - label: "Skip features/"       description: "One doc per product feature"
  - label: "Skip rules.md"        description: "Principles, conventions, anti-patterns"
  - label: "Skip platform/"       description: "Integrations, observability, cloud services"
  - label: "Skip parts/"          description: "Per-part docs with overview + rules + guides"

NOTE: overview.md, architecture.md, repo.md, and problems/ are ALWAYS generated (not skippable).
The full list of docs to generate = all docs MINUS whatever the user checked to skip.
If user checks nothing: all docs are generated (most common case).

### Step 1.3 - Save state

Write `.gen-docs-state.tmp`:
```
phase: 2
type: {monorepo|single}
docs: {comma-separated list of selected docs}
```

Tell the user: "Setup complete. Selected {N} doc types for {type} project. Launching discovery agents..."

Proceed to `## Phase 2`.

---

## Phase 2 - Preview Loop

This phase builds a preview of ALL docs that will be generated. The user reviews and iterates until satisfied.

### Step 2.1 - Launch Discovery Agents

Launch multiple agents in PARALLEL using the `Task` tool. Each agent scans the codebase for a specific doc topic and returns a concise outline of what that doc will contain.

IMPORTANT: On the FIRST run, agents scan the codebase from scratch. On subsequent runs (when user picks "Deepen"), agents receive the current preview as context and focus on finding GAPS and missing information.

Launch one agent per selected doc type. Each agent gets:
- the project type (monorepo/single)
- the list of selected docs (so it knows the full picture)
- if deepening: the current preview content for its topic

Agent tasks by doc type:

overview agent:
- Read README.md, package.json (or equivalent), top-level config files
- Return: project name, description, purpose, related repos, key scripts

architecture agent:
- Use Grep to find entry points, route definitions, main exports, API calls between parts
- Return: data flow between parts, deployment topology
- SINGLE REPO: platform agent findings get merged into this doc as extra sections

concepts agent:
- Use Grep to search for type definitions, interfaces, enums, DB models
- Return: domain entities with 1-line descriptions, their relationships, key business rules

repo agent:
- Read package.json, pyproject.toml, go.mod, Gemfile, tsconfig, docker-compose, etc.
- Use Glob to map folder structure, identify how directories are organized
- Scan for tooling configs: eslint, prettier, husky, lint-staged, commitlint, editorconfig, etc.
- Use Grep for env var references (process.env, os.environ, etc.), read .env.example
- Read Makefile, package.json scripts, shell scripts in scripts/
- Return: tech stack, folder structure, tooling inventory, env vars, services, ports, scripts/commands, setup steps
- MONOREPO NOTE: distinguish between root-level tooling (shared) vs part-specific tooling.
  e.g. "eslint: root + api + web" vs "prettier: root only" vs "commitlint: root only".
  Do NOT assume all parts share the same tooling.

db agent:
- Use Grep to find DB schemas, ORM models/entities, migration files, seed files
- Read DB config files (connection pooling, replicas, timeouts, Cloud SQL, SSL)
- Scan for caching layer (redis, in-memory cache configs)
- Identify patterns: soft deletes, DB views, indexes, subscribers/triggers, audit logs
- Return: data model (entities + relationships), DB config, migrations strategy, seeds, caching setup, DB patterns

cicd agent:
- Read .github/workflows/, .gitlab-ci.yml, Jenkinsfile, bitbucket-pipelines.yml, or equivalent
- Use Grep to find deploy scripts, CI config references
- Return: pipelines, deploy targets, environments, secrets needed, branch strategies, release process

rules agent:
- Use Grep to find existing conventions docs, consistent coding patterns in the codebase
- Identify principles (non-negotiable constraints), conventions (how code is written), anti-patterns (what to never do)
- Return: principles, conventions, anti-patterns for a single rules.md file
- MONOREPO: also identify per-part rules that override/extend root rules

guides agent:
- Scan for repetitive patterns: how controllers are created, how entities are added, how tests are structured
- Identify important decorators, system events, middleware patterns, common abstractions
- Scan test files to understand testing patterns, frameworks, where tests live (for guides/testing.md)
- Look for existing docs, READMEs in subdirectories, or inline comments explaining "how to"
- Return: list of guide topics with 3-5 bullet points each (always include testing.md as a guide)
- MONOREPO: distinguish root-level guides (project-wide) vs part-specific guides

features agent:
- Read route definitions, page components, CLI commands, API endpoints
- Return: list of distinct features, each with name + 3-5 bullet points describing scope

platform agent:
- Scan for 3rd party service integrations (payment, email, SMS, storage, search, CRM, etc.)
- Scan for observability setup (logging, tracing, monitoring, error tracking)
- Scan for cloud provider resources (Cloud Run, Cloud SQL, GCS, Pub/Sub, Lambda, S3, etc.)
- Return: integrations list with purpose, observability stack, cloud services inventory
- MONOREPO: findings go to platform/ folder (3 files)
- SINGLE REPO: findings go as sections inside architecture.md

parts agent (monorepo only):
- For each top-level part dir: read its package.json, scan entry points
- Return: per-part summary (what it does, stack, key patterns, conventions)

problems agent:
- Check for existing solved problem docs, ADRs, CHANGELOG, postmortems
- Return: any existing solved problems found (usually empty on first gen)

### Step 2.2 - Build Preview

Collect all agent results and assemble the preview following `### Preview Format`. Write it to `.gen-docs-state.tmp` after the header section.

If deepening: MERGE new findings into existing preview (add new bullets, don't remove existing ones unless they were wrong).

### Step 2.3 - Show Preview

Display the full preview to the user in a readable format.

### Step 2.4 - Interactive Menu

After showing the preview, display this menu:

```
What's next?
1> deepen   - launch agents again to find gaps and enrich the preview
2> adjust   - tell me what to add, remove, or change
3> generate - preview looks good, create the docs
```

User can type just "1"-"3" OR add details: "1, dig deeper into the auth flow", etc.

Option 1 - deepen:
- Go back to `Step 2.1` with current preview as context for agents
- If user gave direction, focus agents on that specific area
- If no direction, agents look for gaps in the current preview
- After updating preview, return to MENU

Option 2 - adjust:
- User provides free text describing changes (add feature X, remove concept Y, rename Z, etc.)
- Apply the changes directly to the preview in `.gen-docs-state.tmp`
- Show updated preview
- Return to MENU

Option 3 - generate:
- Update state: `phase: 3`
- Proceed to `## Phase 3`

---

## Phase 3 - Generate

Create the `docs/` folder and write all files based on the APPROVED PREVIEW.

### Step 3.1 - Launch Generation Agents

Launch agents in PARALLEL to write the actual doc files. Each agent receives:
- the approved preview for its doc(s)
- the project type
- access to the codebase for referencing real file paths and code

Each agent writes complete, production-quality documentation following these rules:
- Be concise, use bullet points and tables
- Reference actual codebase file paths
- Use ASCII diagrams for architecture (box-drawing chars: ─ │ ┌ ┐ └ ┘ ├ ┤)
- No bold text, no emojis
- The preview bullets are the OUTLINE - expand each bullet into proper documentation
- overview.md MUST include a doc index section listing all generated files with 1-line descriptions
- EVERY generated .md file MUST end with a metadata section (see `### Metadata Format`)

### Step 3.2 - Create folder structure

Based on project type and selected docs, create directories and write all files.

For single repo:
```
docs/
├── overview.md
├── architecture.md
├── repo.md
├── concepts.md
├── db.md
├── cicd.md
├── rules.md
├── guides/
│   └── {topic}.md (one per guide in preview)
├── features/
│   └── {feature-name}.md (one per feature in preview)
└── problems/
```

For monorepo, add:
```
docs/
├── platform/
│   ├── integrations.md
│   ├── observability.md
│   └── cloud-services.md
└── parts/
    └── {part-name}/
        ├── overview.md
        ├── rules.md
        └── guides/
            └── {topic}.md (when part is complex enough)
```

### Step 3.3 - Cleanup

1. Delete `.gen-docs-state.tmp`
2. Show the final folder structure with file count
3. Tell user: "Done! Generated {N} files in docs/. Review them and adjust as needed."

---

## Important Rules

- ALWAYS update `.gen-docs-state.tmp` after completing each sub-step
- If the user interrupts and runs `/gen-docs` again, Phase 0 will resume from the last saved state
- Do NOT create files that were not selected in Phase 1
- For rules.md: single file with principles, conventions, anti-patterns sections
- For problems/: create empty folder (grows over time as problems are solved)
- For guides/: create one .md file per guide topic listed in the approved preview
- For guides/ in parts/: create part-specific guides when the preview lists them
- For features/: create one .md file per feature listed in the approved preview
- For parts/: create one folder per part listed in the approved preview (monorepo only)
- The preview in `.gen-docs-state.tmp` is the SOURCE OF TRUTH for `## Phase 3` - only generate what's in the preview

---

## Reference

### Preview Format

The preview is PER-FILE with bullet points. Each file entry should ALSO include related docs and sources when known (lines starting with `>` are metadata hints so Phase 3 can write metadata without re-scanning).

```
--- PREVIEW ---

overview.md:
  - project: {name} - {description}
  - related repos: {repo-a}, {repo-b}
  - doc index: {N} files across docs/

architecture.md:
  - entry: {entry point} → {main flow}
  - data flow: {part} → {part} → {part}
  - external integrations: {service}, {service}, {service}
  - deployment: {how/where deployed}

concepts.md:
  - {concept}: {1-line description}
  - {concept}: {1-line description}
  - {concept}: {1-line description}

repo.md:
  - stack: {language}, {framework}, {ORM}, {DB}
  - folder structure: {key dirs and what they contain}
  - tooling: {eslint (root + api), prettier (root only), husky, lint-staged, ...}
  - scripts: {available commands from Makefile/package.json}
  - env vars: {VAR_1}, {VAR_2}, {VAR_3} (+ {N} more)
  - services: {service}:{port}, {service}:{port}
  - setup: {key steps to run locally}

db.md:
  - entities: {entity1}, {entity2}, {entity3} (+ {N} more)
  - key relationships: {entity} → {entity}, {entity} → {entity}
  - config: {pooling, replicas, timeouts}
  - migrations: {count} migrations, {strategy}
  - seeds: {how seeding works}
  - caching: {redis/in-memory, strategy}
  - patterns: {soft deletes, views, indexes, etc.}

cicd.md:
  - pipelines: {pipeline 1}, {pipeline 2}
  - deploy: {environments and targets}
  - secrets: {required secrets}
  - branch strategy: {strategy description}

rules.md:
  - principles: {principle 1}, {principle 2}
  - conventions: {convention 1}, {convention 2}
  - anti-patterns: {anti-pattern 1}, {anti-pattern 2}

guides/{topic}.md:
  - {bullet 1}
  - {bullet 2}
  - {bullet 3}

features/{feature-name}.md:
  - {bullet 1}
  - {bullet 2}
  - {bullet 3}

platform/:                              (monorepo only)
  integrations.md:
    - {service}: {purpose} ({N} integrations total)
    - {service}: {purpose}
  observability.md:
    - logging: {framework}
    - tracing: {framework}
    - monitoring: {tools}
  cloud-services.md:
    - {service}: {purpose}
    - {service}: {purpose}

parts/{name}/:                          (monorepo only)
  overview.md:
    - {what it does}, entry: {file}
    - stack: {part-specific stack}
  rules.md:
    - {part-specific rules that override/extend root}
  guides/{topic}.md:
    - {bullet 1}
    - {bullet 2}

problems/:
  - (empty on first gen - grows over time as problems are solved)
```

Metadata hints example:

```
features/booking.md:
  - availability check → hold → payment → confirm
  - cancellation policies: flexible, moderate, strict
  > related docs: concepts.md, features/auth.md, parts/api/overview.md
  > related sources: src/features/booking/, src/models/booking.model.ts, src/routes/booking.routes.ts
```

### Metadata Format

Appended at the bottom of every generated .md file:

```md
---

related docs:
- docs/concepts.md - booking entity definition, states
- docs/features/auth.md - user must be authenticated to book
- docs/parts/api/overview.md - booking endpoints live here

related sources:
- src/features/booking/ - booking module root
- src/features/booking/service.ts - core booking logic
- src/models/booking.model.ts - DB model
- src/routes/booking.routes.ts - API endpoints
- tests/booking/ - booking tests
```

Rules:
- related docs: other docs in docs/ that THIS doc depends on (unidirectional, no back-links)
- related sources: actual codebase files AND folders relevant to this doc's topic
- list folders when the whole directory is relevant, list specific files when only that file matters
- keep it focused: only list things that are directly relevant, not tangentially related
- overview.md does NOT need related docs (it IS the index) but should list key source files/folders
